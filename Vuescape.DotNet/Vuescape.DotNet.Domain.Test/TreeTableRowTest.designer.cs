// --------------------------------------------------------------------------------------------------------------------
// <auto-generated>
//   Generated using OBeautifulCode.CodeGen.ModelObject (1.0.151.0)
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Vuescape.DotNet.Domain.Test
{
    using global::System;
    using global::System.CodeDom.Compiler;
    using global::System.Collections.Concurrent;
    using global::System.Collections.Generic;
    using global::System.Collections.ObjectModel;
    using global::System.Diagnostics.CodeAnalysis;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Reflection;

    using global::FakeItEasy;

    using global::OBeautifulCode.Assertion.Recipes;
    using global::OBeautifulCode.AutoFakeItEasy;
    using global::OBeautifulCode.CodeGen.ModelObject.Recipes;
    using global::OBeautifulCode.Equality.Recipes;
    using global::OBeautifulCode.Math.Recipes;
    using global::OBeautifulCode.Reflection.Recipes;
    using global::OBeautifulCode.Representation.System;
    using global::OBeautifulCode.Serialization;
    using global::OBeautifulCode.Serialization.Recipes;
    using global::OBeautifulCode.Type;

    using global::Xunit;

    using static global::System.FormattableString;

    public static partial class TreeTableRowTest
    {
        private static readonly StringRepresentationTestScenarios<TreeTableRow> StringRepresentationTestScenarios = new StringRepresentationTestScenarios<TreeTableRow>()
            .AddScenario(() =>
                new StringRepresentationTestScenario<TreeTableRow>
                {
                    Name = "Default Code Generated Scenario",
                    SystemUnderTestExpectedStringRepresentationFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedStringRepresentation<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            ExpectedStringRepresentation = Invariant($"Vuescape.DotNet.Domain.TreeTableRow: Id = {systemUnderTest.Id?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, Name = {systemUnderTest.Name?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, CssClasses = {systemUnderTest.CssClasses?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, Depth = {systemUnderTest.Depth.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, Dependencies = {systemUnderTest.Dependencies?.ToString() ?? "<null>"}, IsExpandable = {systemUnderTest.IsExpandable.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, IsExpanded = {systemUnderTest.IsExpanded.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, IsFocused = {systemUnderTest.IsFocused?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, IsSelected = {systemUnderTest.IsSelected.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, IsVisible = {systemUnderTest.IsVisible.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, Items = {systemUnderTest.Cells?.ToString() ?? "<null>"}, Renderer = {systemUnderTest.Renderer?.ToString(CultureInfo.InvariantCulture) ?? "<null>"}, Value = {systemUnderTest.Value?.ToString() ?? "<null>"}, Children = {systemUnderTest.Children?.ToString() ?? "<null>"}, Links = {systemUnderTest.Links?.ToString() ?? "<null>"}."),
                        };

                        return result;
                    },
                });

        private static readonly ConstructorArgumentValidationTestScenarios<TreeTableRow> ConstructorArgumentValidationTestScenarios = new ConstructorArgumentValidationTestScenarios<TreeTableRow>()
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'id' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             null,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "id", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'id' is white space scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             Invariant($"  {Environment.NewLine}  "),
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "id", "white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'name' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             null,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "name", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'name' is white space scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             Invariant($"  {Environment.NewLine}  "),
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "name", "white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'cssClasses' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             null,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "cssClasses", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'cssClasses' is white space scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             Invariant($"  {Environment.NewLine}  "),
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "cssClasses", "white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'items' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             null,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "items", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'items' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             new List<TreeTableCell>(),
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "items", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'items' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             new TreeTableCell[0].Concat((IReadOnlyList<TreeTableCell>)referenceObject.Cells).Concat(new TreeTableCell[] { null }).Concat((IReadOnlyList<TreeTableCell>)referenceObject.Cells).ToList(),
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "items", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'renderer' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             null,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "renderer", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'renderer' is white space scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             Invariant($"  {Environment.NewLine}  "),
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "renderer", "white space", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'value' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             null,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "value", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'children' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             null,
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "children", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'children' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             new List<TreeTableRow>(),
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "children", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'children' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             new TreeTableRow[0].Concat((IReadOnlyList<TreeTableRow>)referenceObject.Children).Concat(new TreeTableRow[] { null }).Concat((IReadOnlyList<TreeTableRow>)referenceObject.Children).ToList(),
                                             referenceObject.Dependencies,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "children", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'dependencies' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             null,
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "dependencies", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'dependencies' is an empty enumerable scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             new List<TreeTableRowDependency>(),
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "dependencies", "is an empty enumerable", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'dependencies' contains a null element scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             new TreeTableRowDependency[0].Concat(referenceObject.Dependencies).Concat(new TreeTableRowDependency[] { null }).Concat(referenceObject.Dependencies).ToList(),
                                             referenceObject.Links);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "dependencies", "contains at least one null element", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentNullException when parameter 'links' is null scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             null);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentNullException),
                    ExpectedExceptionMessageContains = new[] { "links", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'links' is an empty dictionary scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             new Dictionary<string, IReadOnlyCollection<Link>>());

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "links", "is an empty dictionary", },
                })
            .AddScenario(() =>
                new ConstructorArgumentValidationTestScenario<TreeTableRow>
                {
                    Name = "constructor should throw ArgumentException when parameter 'links' contains a key-value pair with a null value scenario",
                    ConstructionFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var dictionaryWithNullValue = referenceObject.Links.ToDictionary(_ => _.Key, _ => _.Value);

                        var randomKey = dictionaryWithNullValue.Keys.ElementAt(ThreadSafeRandom.Next(0, dictionaryWithNullValue.Count));

                        dictionaryWithNullValue[randomKey] = null;

                        var result = new TreeTableRow(
                                             referenceObject.Id,
                                             referenceObject.Name,
                                             referenceObject.CssClasses,
                                             referenceObject.Depth,
                                             referenceObject.IsExpandable,
                                             referenceObject.IsExpanded,
                                             referenceObject.IsFocused,
                                             referenceObject.IsSelected,
                                             referenceObject.IsVisible,
                                             (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                             referenceObject.Renderer,
                                             referenceObject.Value,
                                             (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                             referenceObject.Dependencies,
                                             dictionaryWithNullValue);

                        return result;
                    },
                    ExpectedExceptionType = typeof(ArgumentException),
                    ExpectedExceptionMessageContains = new[] { "links", "contains at least one key-value pair with a null value", },
                });

        private static readonly ConstructorPropertyAssignmentTestScenarios<TreeTableRow> ConstructorPropertyAssignmentTestScenarios = new ConstructorPropertyAssignmentTestScenarios<TreeTableRow>()
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Id should return same 'id' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Id,
                        };

                        return result;
                    },
                    PropertyName = "Id",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Name should return same 'name' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Name,
                        };

                        return result;
                    },
                    PropertyName = "Name",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "CssClasses should return same 'cssClasses' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.CssClasses,
                        };

                        return result;
                    },
                    PropertyName = "CssClasses",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Depth should return same 'depth' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Depth,
                        };

                        return result;
                    },
                    PropertyName = "Depth",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "IsExpandable should return same 'isExpandable' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.IsExpandable,
                        };

                        return result;
                    },
                    PropertyName = "IsExpandable",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "IsExpanded should return same 'isExpanded' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.IsExpanded,
                        };

                        return result;
                    },
                    PropertyName = "IsExpanded",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "IsFocused should return same 'isFocused' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.IsFocused,
                        };

                        return result;
                    },
                    PropertyName = "IsFocused",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "IsSelected should return same 'isSelected' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.IsSelected,
                        };

                        return result;
                    },
                    PropertyName = "IsSelected",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "IsVisible should return same 'isVisible' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.IsVisible,
                        };

                        return result;
                    },
                    PropertyName = "IsVisible",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Items should return same 'items' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Cells,
                        };

                        return result;
                    },
                    PropertyName = "Items",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Renderer should return same 'renderer' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Renderer,
                        };

                        return result;
                    },
                    PropertyName = "Renderer",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Value should return same 'value' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Value,
                        };

                        return result;
                    },
                    PropertyName = "Value",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Children should return same 'children' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Children,
                        };

                        return result;
                    },
                    PropertyName = "Children",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Dependencies should return same 'dependencies' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Dependencies,
                        };

                        return result;
                    },
                    PropertyName = "Dependencies",
                })
            .AddScenario(() =>
                new ConstructorPropertyAssignmentTestScenario<TreeTableRow>
                {
                    Name = "Links should return same 'links' parameter passed to constructor when getting",
                    SystemUnderTestExpectedPropertyValueFunc = () =>
                    {
                        var referenceObject = A.Dummy<TreeTableRow>();

                        var result = new SystemUnderTestExpectedPropertyValue<TreeTableRow>
                        {
                            SystemUnderTest = new TreeTableRow(
                                                      referenceObject.Id,
                                                      referenceObject.Name,
                                                      referenceObject.CssClasses,
                                                      referenceObject.Depth,
                                                      referenceObject.IsExpandable,
                                                      referenceObject.IsExpanded,
                                                      referenceObject.IsFocused,
                                                      referenceObject.IsSelected,
                                                      referenceObject.IsVisible,
                                                      (IReadOnlyList<TreeTableCell>)referenceObject.Cells,
                                                      referenceObject.Renderer,
                                                      referenceObject.Value,
                                                      (IReadOnlyList<TreeTableRow>)referenceObject.Children,
                                                      referenceObject.Dependencies,
                                                      referenceObject.Links),
                            ExpectedPropertyValue = referenceObject.Links,
                        };

                        return result;
                    },
                    PropertyName = "Links",
                });

        private static readonly DeepCloneWithTestScenarios<TreeTableRow> DeepCloneWithTestScenarios = new DeepCloneWithTestScenarios<TreeTableRow>()
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithId should deep clone object and replace Id with the provided id",
                    WithPropertyName = "Id",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Id.IsEqualTo(_.Id));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Id,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithName should deep clone object and replace Name with the provided name",
                    WithPropertyName = "Name",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Name.IsEqualTo(_.Name));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Name,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithCssClasses should deep clone object and replace CssClasses with the provided cssClasses",
                    WithPropertyName = "CssClasses",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.CssClasses.IsEqualTo(_.CssClasses));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.CssClasses,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithDepth should deep clone object and replace Depth with the provided depth",
                    WithPropertyName = "Depth",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Depth.IsEqualTo(_.Depth));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Depth,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithDependencies should deep clone object and replace Dependencies with the provided dependencies",
                    WithPropertyName = "Dependencies",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Dependencies.IsEqualTo(_.Dependencies));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Dependencies,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithIsExpandable should deep clone object and replace IsExpandable with the provided isExpandable",
                    WithPropertyName = "IsExpandable",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.IsExpandable.IsEqualTo(_.IsExpandable));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.IsExpandable,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithIsExpanded should deep clone object and replace IsExpanded with the provided isExpanded",
                    WithPropertyName = "IsExpanded",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.IsExpanded.IsEqualTo(_.IsExpanded));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.IsExpanded,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithIsFocused should deep clone object and replace IsFocused with the provided isFocused",
                    WithPropertyName = "IsFocused",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.IsFocused.IsEqualTo(_.IsFocused));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.IsFocused,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithIsSelected should deep clone object and replace IsSelected with the provided isSelected",
                    WithPropertyName = "IsSelected",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.IsSelected.IsEqualTo(_.IsSelected));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.IsSelected,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithIsVisible should deep clone object and replace IsVisible with the provided isVisible",
                    WithPropertyName = "IsVisible",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.IsVisible.IsEqualTo(_.IsVisible));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.IsVisible,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithItems should deep clone object and replace Items with the provided items",
                    WithPropertyName = "Items",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Cells.IsEqualTo(_.Cells));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Cells,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithRenderer should deep clone object and replace Renderer with the provided renderer",
                    WithPropertyName = "Renderer",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Renderer.IsEqualTo(_.Renderer));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Renderer,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithValue should deep clone object and replace Value with the provided value",
                    WithPropertyName = "Value",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Value.IsEqualTo(_.Value));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Value,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithChildren should deep clone object and replace Children with the provided children",
                    WithPropertyName = "Children",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Children.IsEqualTo(_.Children));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Children,
                        };

                        return result;
                    },
                })
            .AddScenario(() =>
                new DeepCloneWithTestScenario<TreeTableRow>
                {
                    Name = "DeepCloneWithLinks should deep clone object and replace Links with the provided links",
                    WithPropertyName = "Links",
                    SystemUnderTestDeepCloneWithValueFunc = () =>
                    {
                        var systemUnderTest = A.Dummy<TreeTableRow>();

                        var referenceObject = A.Dummy<TreeTableRow>().ThatIs(_ => !systemUnderTest.Links.IsEqualTo(_.Links));

                        var result = new SystemUnderTestDeepCloneWithValue<TreeTableRow>
                        {
                            SystemUnderTest = systemUnderTest,
                            DeepCloneWithValue = referenceObject.Links,
                        };

                        return result;
                    },
                });

        private static readonly TreeTableRow ReferenceObjectForEquatableTestScenarios = A.Dummy<TreeTableRow>();

        private static readonly EquatableTestScenarios<TreeTableRow> EquatableTestScenarios = new EquatableTestScenarios<TreeTableRow>()
            .AddScenario(() =>
                new EquatableTestScenario<TreeTableRow>
                {
                    Name = "Default Code Generated Scenario",
                    ReferenceObject = ReferenceObjectForEquatableTestScenarios,
                    ObjectsThatAreEqualToButNotTheSameAsReferenceObject = new TreeTableRow[]
                    {
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                    },
                    ObjectsThatAreNotEqualToReferenceObject = new TreeTableRow[]
                    {
                        new TreeTableRow(
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Id.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Id)).Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Name.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Name)).Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.CssClasses.IsEqualTo(ReferenceObjectForEquatableTestScenarios.CssClasses)).CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Depth.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Depth)).Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Dependencies.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Dependencies)).Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.IsExpandable.IsEqualTo(ReferenceObjectForEquatableTestScenarios.IsExpandable)).IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.IsExpanded.IsEqualTo(ReferenceObjectForEquatableTestScenarios.IsExpanded)).IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.IsFocused.IsEqualTo(ReferenceObjectForEquatableTestScenarios.IsFocused)).IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.IsSelected.IsEqualTo(ReferenceObjectForEquatableTestScenarios.IsSelected)).IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.IsVisible.IsEqualTo(ReferenceObjectForEquatableTestScenarios.IsVisible)).IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)A.Dummy<TreeTableRow>().Whose(_ => !_.Cells.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Cells)).Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Renderer.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Renderer)).Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Value.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Value)).Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)A.Dummy<TreeTableRow>().Whose(_ => !_.Children.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Children)).Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                ReferenceObjectForEquatableTestScenarios.Links),
                        new TreeTableRow(
                                ReferenceObjectForEquatableTestScenarios.Id,
                                ReferenceObjectForEquatableTestScenarios.Name,
                                ReferenceObjectForEquatableTestScenarios.CssClasses,
                                ReferenceObjectForEquatableTestScenarios.Depth,
                                ReferenceObjectForEquatableTestScenarios.IsExpandable,
                                ReferenceObjectForEquatableTestScenarios.IsExpanded,
                                ReferenceObjectForEquatableTestScenarios.IsFocused,
                                ReferenceObjectForEquatableTestScenarios.IsSelected,
                                ReferenceObjectForEquatableTestScenarios.IsVisible,
                                (IReadOnlyList<TreeTableCell>)ReferenceObjectForEquatableTestScenarios.Cells,
                                ReferenceObjectForEquatableTestScenarios.Renderer,
                                ReferenceObjectForEquatableTestScenarios.Value,
                                (IReadOnlyList<TreeTableRow>)ReferenceObjectForEquatableTestScenarios.Children,
                                ReferenceObjectForEquatableTestScenarios.Dependencies,
                                A.Dummy<TreeTableRow>().Whose(_ => !_.Links.IsEqualTo(ReferenceObjectForEquatableTestScenarios.Links)).Links),
                    },
                    ObjectsThatAreNotOfTheSameTypeAsReferenceObject = new object[]
                    {
                        A.Dummy<object>(),
                        A.Dummy<string>(),
                        A.Dummy<int>(),
                        A.Dummy<int?>(),
                        A.Dummy<Guid>(),
                    },
                });

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Structural
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void TreeTableRow___Should_implement_IModel_of_TreeTableRow___When_reflecting()
            {
                // Arrange
                var type = typeof(TreeTableRow);

                var expectedModelMethods = typeof(IModel<TreeTableRow>).GetInterfaceDeclaredAndImplementedMethods();

                var expectedModelMethodHashes = expectedModelMethods.Select(_ => _.GetSignatureHash());

                // Act
                var actualInterfaces = type.GetInterfaces();
                var actualModelMethods = type.GetMethodsFiltered(MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public).ToList();
                var actualModelMethodHashes = actualModelMethods.Select(_ => _.GetSignatureHash());

                // Assert
                actualInterfaces.AsTest().Must().ContainElement(typeof(IModel<TreeTableRow>));
                expectedModelMethodHashes.Except(actualModelMethodHashes).AsTest().Must().BeEmptyEnumerable();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void TreeTableRow___Should_be_attributed_with_Serializable____When_reflecting()
            {
                // Arrange
                var type = typeof(TreeTableRow);

                // Act
                var actualAttributes = type.GetCustomAttributes(typeof(SerializableAttribute), false);

                // Assert
                actualAttributes.AsTest().Must().NotBeEmptyEnumerable();
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class StringRepresentation
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void ToString___Should_generate_friendly_string_representation_of_object___When_called()
            {
                var scenarios = StringRepresentationTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.SystemUnderTest.ToString();

                    // Assert
                    actual.AsTest().Must().BeEqualTo(scenario.ExpectedStringRepresentation, because: scenario.Id);
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Constructing
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Constructor___Should_throw___When_parameters_are_not_valid()
            {
                var scenarios = ConstructorArgumentValidationTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = Record.Exception(scenario.ConstructionFunc);

                    // Assert
                    actual.AsTest().Must().BeOfType(scenario.ExpectedExceptionType, because: scenario.Id);

                    foreach(var expected in scenario.ExpectedExceptionMessageContains ?? new List<string>())
                    {
                        actual.Message.AsTest().Must().ContainString(expected, because: scenario.Id);
                    }

                    if (scenario.ExpectedExceptionMessageEquals != null)
                    {
                        actual.Message.AsTest().Must().BeEqualTo(scenario.ExpectedExceptionMessageEquals, because: scenario.Id);
                    }
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "referenceObject")]
            public static void Properties___Should_be_assigned_by_constructor_to_expected_value___When_getting()
            {
                var scenarios = ConstructorPropertyAssignmentTestScenarios.ValidateAndPrepareForTesting();

                var obcAssertionAsTestMethod = typeof(WorkflowExtensions).GetMethodFiltered(nameof(WorkflowExtensions.AsTest), MemberRelationships.DeclaredInType, MemberOwners.Static, MemberAccessModifiers.Public);

                var obcAssertionBeEqualToMethod = typeof(Verifications).GetMethodFiltered(nameof(Verifications.BeEqualTo), MemberRelationships.DeclaredInType, MemberOwners.Static, MemberAccessModifiers.Public);

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    if ((scenario.PropertyName == ConstructorPropertyAssignmentTestScenario.NoPropertiesAssignedInConstructorScenarioPropertyName) || (scenario.PropertyName == ConstructorPropertyAssignmentTestScenario.ForceGeneratedTestsToPassAndWriteMyOwnScenarioPropertyName))
                    {
                        continue;
                    }

                    // Act
                    var actual = scenario.Property.GetValue(scenario.SystemUnderTest);

                    // Assert
                    if (scenario.CompareActualToExpectedUsing == CompareActualToExpectedUsing.ValueEquality)
                    {
                        var propertyType = scenario.Property.PropertyType;

                        // Use reflection to call: actual.AsTest().Must().BeEqualTo(scenario.ExpectedPropertyValue, because: scenario.Id)
                        // We need to use reflection here to specify the 'subject' and 'comparisonValue' types.
                        // BeEqualTo() uses declared types and not runtime types to identify the contract to use for equality.
                        // Here 'scenario.ExpectedPropertyValue' and 'actual' are declared as typeof(object).
                        // With the exception of some specific boxed types (e.g. value types, string),
                        // BeEqualTo() uses reference equality to compare two objects declared as typeof(object).
                        // We want to use the property's real type, 'scenario.Property.PropertyType'.
                        // For example, BeEqualTo() returns false for these two dictionaries because their declared type is typeof(object):
                        // object x = Dictionary<string, string>();
                        // object y = Dictionary<string, string>();
                        var assertionTracker = ((AssertionTracker)obcAssertionAsTestMethod.MakeGenericMethod(propertyType).Invoke(null, new[] { actual, Type.Missing })).Must();

                        var invokeableObcAssertionBeEqualToMethod = obcAssertionBeEqualToMethod.MakeGenericMethod(propertyType);

                        invokeableObcAssertionBeEqualToMethod.Invoke(null, new object[] { assertionTracker, scenario.ExpectedPropertyValue, scenario.Id, Type.Missing, Type.Missing });
                    }
                    else if (scenario.CompareActualToExpectedUsing == CompareActualToExpectedUsing.ReferenceEquality)
                    {
                        actual.AsTest().Must().BeSameReferenceAs(scenario.ExpectedPropertyValue, because: scenario.Id);
                    }
                    else
                    {
                        throw new NotSupportedException("This CompareActualToExpectedUsing is not supported: " + scenario.CompareActualToExpectedUsing);
                    }
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Cloning
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Clone___Should_clone_object___When_called()
            {
                // Arrange
                var systemUnderTest = A.Dummy<TreeTableRow>();

                // Act
                var actual = (TreeTableRow)systemUnderTest.Clone();

                // Assert
                actual.AsTest().Must().BeEqualTo(systemUnderTest);
                actual.AsTest().Must().NotBeSameReferenceAs(systemUnderTest);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void DeepClone___Should_deep_clone_object___When_called()
            {
                // Arrange
                var systemUnderTest = A.Dummy<TreeTableRow>();

                // Act
                var actual = systemUnderTest.DeepClone();

                // Assert
                actual.AsTest().Must().BeEqualTo(systemUnderTest);
                actual.AsTest().Must().NotBeSameReferenceAs(systemUnderTest);

                if (systemUnderTest.Dependencies == null)
                {
                    actual.Dependencies.AsTest().Must().BeNull();
                }
                else
                {
                    actual.Dependencies.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.Dependencies);
                }

                if (systemUnderTest.Cells == null)
                {
                    actual.Cells.AsTest().Must().BeNull();
                }
                else
                {
                    actual.Cells.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.Cells);
                }

                if (systemUnderTest.Value == null)
                {
                    actual.Value.AsTest().Must().BeNull();
                }
                else
                {
                    actual.Value.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.Value);
                }

                if (systemUnderTest.Children == null)
                {
                    actual.Children.AsTest().Must().BeNull();
                }
                else
                {
                    actual.Children.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.Children);
                }

                if (systemUnderTest.Links == null)
                {
                    actual.Links.AsTest().Must().BeNull();
                }
                else
                {
                    actual.Links.AsTest().Must().NotBeSameReferenceAs(systemUnderTest.Links);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void DeepCloneWith___Should_deep_clone_object_and_replace_the_associated_property_with_the_provided_value___When_called()
            {
                var propertyNames = new string[] { "Id", "Name", "CssClasses", "Depth", "Dependencies", "IsExpandable", "IsExpanded", "IsFocused", "IsSelected", "IsVisible", "Items", "Renderer", "Value", "Children", "Links" };

                var scenarios = DeepCloneWithTestScenarios.ValidateAndPrepareForTesting();

                var obcAssertionAsTestMethod = typeof(WorkflowExtensions).GetMethodFiltered(nameof(WorkflowExtensions.AsTest), MemberRelationships.DeclaredInType, MemberOwners.Static, MemberAccessModifiers.Public);

                var obcAssertionBeEqualToMethod = typeof(Verifications).GetMethodFiltered(nameof(Verifications.BeEqualTo), MemberRelationships.DeclaredInType, MemberOwners.Static, MemberAccessModifiers.Public);

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    if (scenario.WithPropertyName == DeepCloneWithTestScenario.ForceGeneratedTestsToPassAndWriteMyOwnScenarioWithPropertyName)
                    {
                        continue;
                    }

                    // Act
                    var actual = (TreeTableRow)scenario.DeepCloneWithMethod.Invoke(scenario.SystemUnderTest, new[] { scenario.WithValue });

                    // Assert
                    foreach(var propertyName in propertyNames)
                    {
                        var propertyInfo = typeof(TreeTableRow).GetPropertyFiltered(propertyName, MemberRelationships.DeclaredOrInherited, MemberOwners.Instance, MemberAccessModifiers.Public);

                        var propertyType = propertyInfo.PropertyType;

                        var actualPropertyValue = propertyInfo.GetValue(actual);

                        if (propertyName == scenario.WithPropertyName)
                        {
                            if (propertyType.IsValueType)
                            {
                                actualPropertyValue.AsTest().Must().BeEqualTo(scenario.WithValue, because: scenario.Id);
                            }
                            else
                            {
                                actualPropertyValue.AsTest().Must().BeSameReferenceAs(scenario.WithValue, because: scenario.Id);
                            }
                        }
                        else
                        {
                            var systemUnderTestPropertyValue = propertyInfo.GetValue(scenario.SystemUnderTest);

                            // Use reflection to call: actualPropertyValue.AsTest().Must().BeEqualTo(systemUnderTestPropertyValue, because: scenario.Id)
                            // We need to use reflection here to specify the 'subject' and 'comparisonValue' types.
                            // BeEqualTo() uses declared types and not runtime types to identify the contract to use for equality.
                            // Here 'systemUnderTestPropertyValue' and 'actualPropertyValue' are declared as typeof(object).
                            // With the exception of some specific boxed types (e.g. value types, string),
                            // BeEqualTo() uses reference equality to compare two objects declared as typeof(object).
                            // We want to use the property's real type, 'property.PropertyType'.
                            // For example, BeEqualTo() returns false for these two dictionaries because their declared type is typeof(object):
                            // object x = Dictionary<string, string>();
                            // object y = Dictionary<string, string>();
                            var assertionTracker = ((AssertionTracker)obcAssertionAsTestMethod.MakeGenericMethod(propertyType).Invoke(null, new[] { actualPropertyValue, Type.Missing })).Must();

                            var invokeableObcAssertionBeEqualToMethod = obcAssertionBeEqualToMethod.MakeGenericMethod(propertyType);

                            invokeableObcAssertionBeEqualToMethod.Invoke(null, new object[] { assertionTracker, systemUnderTestPropertyValue, scenario.Id, Type.Missing, Type.Missing });

                            if ((!propertyType.IsValueType) && (propertyType != typeof(string)) && (systemUnderTestPropertyValue != null))
                            {
                                actualPropertyValue.AsTest().Must().NotBeSameReferenceAs(systemUnderTestPropertyValue, because: scenario.Id);
                            }
                        }
                    }
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Serialization
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_string_using_ObcBsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<TreeTableRow>();

                var serializationConfigurationType = SerializationConfigurationTypes.BsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.String };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaBsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_bytes_using_ObcBsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<TreeTableRow>();

                var serializationConfigurationType = SerializationConfigurationTypes.BsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.Binary };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaBsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_string_using_ObcJsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<TreeTableRow>();

                var serializationConfigurationType = SerializationConfigurationTypes.JsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.String };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaJsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Deserialize___Should_roundtrip_object___When_serializing_to_and_deserializing_from_bytes_using_ObcJsonSerializer()
            {
                // Arrange
                var expected = A.Dummy<TreeTableRow>();

                var serializationConfigurationType = SerializationConfigurationTypes.JsonSerializationConfigurationType.ConcreteSerializationConfigurationDerivativeType;

                var serializationFormats = new[] { SerializationFormat.Binary };

                var appDomainScenarios = AppDomainScenarios.RoundtripInCurrentAppDomain | AppDomainScenarios.SerializeInCurrentAppDomainAndDeserializeInNewAppDomain;

                // Act, Assert
                expected.RoundtripSerializeViaJsonWithBeEqualToAssertion(serializationConfigurationType, serializationFormats, appDomainScenarios);
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Equality
        {
            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_both_sides_of_operator_are_null()
            {
                // Arrange
                TreeTableRow systemUnderTest1 = null;
                TreeTableRow systemUnderTest2 = null;

                // Act
                var actual = systemUnderTest1 == systemUnderTest2;

                // Assert
                actual.AsTest().Must().BeTrue();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_one_side_of_operator_is_null_and_the_other_side_is_not_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    TreeTableRow systemUnderTest = null;

                    // Act
                    var actual1 = systemUnderTest == scenario.ReferenceObject;
                    var actual2 = scenario.ReferenceObject == systemUnderTest;

                    // Assert
                    actual1.AsTest().Must().BeFalse(because: scenario.Id);
                    actual2.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_same_object_is_on_both_sides_of_operator()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    #pragma warning disable CS1718 // Comparison made to same variable
                    var actual = scenario.ReferenceObject == scenario.ReferenceObject;
                    #pragma warning restore CS1718 // Comparison made to same variable

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_objects_being_compared_derive_from_the_same_type_but_are_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void EqualsOperator___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject == _).ToList();
                    var actuals2 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _ == scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_both_sides_of_operator_are_null()
            {
                // Arrange
                TreeTableRow systemUnderTest1 = null;
                TreeTableRow systemUnderTest2 = null;

                // Act
                var actual = systemUnderTest1 != systemUnderTest2;

                // Assert
                actual.AsTest().Must().BeFalse();
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_one_side_of_operator_is_null_and_the_other_side_is_not_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    TreeTableRow systemUnderTest = null;

                    // Act
                    var actual1 = systemUnderTest != scenario.ReferenceObject;
                    var actual2 = scenario.ReferenceObject != systemUnderTest;

                    // Assert
                    actual1.AsTest().Must().BeTrue(because: scenario.Id);
                    actual2.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_same_object_is_on_both_sides_of_operator()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    #pragma warning disable CS1718 // Comparison made to same variable
                    var actual = scenario.ReferenceObject != scenario.ReferenceObject;
                    #pragma warning restore CS1718 // Comparison made to same variable

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_objects_being_compared_derive_from_the_same_type_but_are_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_true___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeTrue(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void NotEqualsOperator___Should_return_false___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject != _).ToList();
                    var actuals2 = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _ != scenario.ReferenceObject).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_TreeTableRow___Should_return_false___When_parameter_other_is_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange
                    TreeTableRow systemUnderTest = null;

                    // Act
                    var actual = scenario.ReferenceObject.Equals(systemUnderTest);

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_TreeTableRow___Should_return_true___When_parameter_other_is_same_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals(scenario.ReferenceObject);

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_TreeTableRow___Should_return_false___When_parameter_other_is_derived_from_the_same_type_but_is_not_of_the_same_type_as_this_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_TreeTableRow___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_TreeTableRow___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals(_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_parameter_other_is_null()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals((object)null);

                    // Assert
                    actual.AsTest().Must().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_parameter_other_is_not_of_the_same_type()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals1 = scenario.ObjectsThatDeriveFromScenarioTypeButAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();
                    var actuals2 = scenario.ObjectsThatAreNotOfTheSameTypeAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals1.AsTest().Must().Each().BeFalse(because: scenario.Id);
                    actuals2.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_true___When_parameter_other_is_same_object()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actual = scenario.ReferenceObject.Equals((object)scenario.ReferenceObject);

                    // Assert
                    actual.AsTest().Must().BeTrue(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_false___When_objects_being_compared_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeFalse(because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void Equals_with_Object___Should_return_true___When_objects_being_compared_have_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => scenario.ReferenceObject.Equals((object)_)).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeTrue(because: scenario.Id);
                }
            }
        }

        [SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        [SuppressMessage("Microsoft.Naming", "CA1724:TypeNamesShouldNotMatchNamespaces")]
        public static class Hashing
        {
            [Fact(Skip = "It's possible (and even probable after a few runs of this test) that two dummy, unequal models will have the same hash code.  The model being tested contains at least one property who's type (or a type nested within the generic type, or a property of the IModel type) is a dictionary with keys that are not comparable or an unordered collection with elements that are not comparable.  In these cases the hashing method cannot hash the elements and must resort to hashing the element count.  Two dummies could easily have the same element count for such a type.")]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void GetHashCode___Should_not_be_equal_for_two_objects___When_objects_have_different_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var unexpected = scenario.ReferenceObject.GetHashCode();

                    var actuals = scenario.ObjectsThatAreNotEqualToReferenceObject.Select(_ => _.GetHashCode()).ToList();

                    // Assert
                    actuals.AsTest().Must().NotContainElement(unexpected, because: scenario.Id);
                }
            }

            [Fact]
            [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
            [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
            [SuppressMessage("Microsoft.Naming", "CA1715:IdentifiersShouldHaveCorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
            [SuppressMessage("Microsoft.Naming", "CA1719:ParameterNamesShouldNotMatchMemberNames")]
            [SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames")]
            [SuppressMessage("Microsoft.Naming", "CA1722:IdentifiersShouldNotHaveIncorrectPrefix")]
            [SuppressMessage("Microsoft.Naming", "CA1725:ParameterNamesShouldMatchBaseDeclaration")]
            [SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms")]
            [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly")]
            public static void GetHashCode___Should_be_equal_for_two_objects___When_objects_have_the_same_property_values()
            {
                var scenarios = EquatableTestScenarios.ValidateAndPrepareForTesting();

                foreach (var scenario in scenarios)
                {
                    // Arrange, Act
                    var expected = scenario.ReferenceObject.GetHashCode();

                    var actuals = scenario.ObjectsThatAreEqualToButNotTheSameAsReferenceObject.Select(_ => _.GetHashCode()).ToList();

                    // Assert
                    actuals.AsTest().Must().Each().BeEqualTo(expected, because: scenario.Id);
                }
            }
        }
    }
}